# Homework Assignment: Tree Traversal with Stacks and Queues

## Overview
In this assignment, you will implement a generic *tree* data structure and use stacks and queues to perform depth-first search (DFS) and breadth-first search (BFS) traversals.

Note that the repository already contains the implementation of generic lists, stacks, and queues seen in class. You can and should reuse them in your implementation. The given implementation of queues contains one more method than what we have seen in class, namely
a `toList` method that may be useful for this assignment.

## Part 1: Tree Node Class
In this section, we implement a generic `TreeNode<T>` class that represents a tree-node. Recall that such a tree-node contains a piece of data (of type `T`) and a collection of children. If the collection of children is empty, the tree-node is called a leaf.

For our implementation, we choose to represent the collection of children of a tree-node as a linked list of linked node.

Our class will have a single constructor that creates a leaf containing the value passed in argument. It must also have methods `addChild`, `getChildren`, and `getValue`.

```java
public class TreeNode<T> {
    // TODO: Implement the two fields

    public TreeNode(T value) {
        // TODO: Initialize the node
        // The resulting node contains `value` as data
        // and have an empty list of children.
    }

    public void addChild(TreeNode<T> child) {
        // TODO: Add a child to this node
        // You can choose *where* to add the child
        // but try to opt for the most time-efficient.
    }

    public List<TreeNode<T>> getChildren() {
        // TODO: Return the list of children
    }

    public T getValue() {
        // TODO: Return the node's value
    }
}
```

## Part 2: Tree Class
Implement a generic `Tree<T>` class that manages the entire tree structure. A tree is simply, given by a tree-node, named *root*.

The constructor method without argument will make an empty tree. The constructor method with a tree-node argument will construct a tree in which the argument is the root.

We will also need setter and getter methods.

```java
public class Tree<T> {
    // TODO: Implement the unique field

    public Tree() {
        // TODO: Initialize the tree
    }

    public Tree(TreeNode<T> root) {
        // TODO: Initialize the tree with a root
    }

    public void setRoot(TreeNode<T> root) {
        // TODO: Set the root node
    }

    public TreeNode<T> getRoot() {
        // TODO: Return the root node
    }
}
```

## Part 3: Breadth-First Search
In this section, we focus on BFS traversals of trees. The idea of BFS is to explore all children of a given node before moving deeper. Here is an algorithm with one crucial *missing* piece, namely what data structures to use for the collections C and R:

```
1. Create an empty collection R
2. If tree is empty, return R
3. Create a collection C and add the root to it
4. While C is not empty:
    a. Remove the next element (a tree-node) of C
    b. Add its value to R
    c. Add all its children to C
5. Return R
```

The following example shows the expected result of BFS.
```
  Example tree:

                1
              / | \
             2  3  4
            /|     |\
           5 6     7 8

    BFS should yield: 1, 2, 3, 4, 5, 6, 7, 8
```

__Question 1__: 
What data structures should you use for R and C? For each of them, describe what "remove" and "add" means.

Add a method to your tree class that returns the BFS traversal:

```java
public List<T> breadthFirstSearch() {
    // TODO: Implement BFS
    // Don't forget to transform your collection R into a list at the end (if it is not already)
}
```

## Part 4: Depth-First Search
In this section, we focus on DFS traversals of trees. The idea of DFS is to explore every branch as deep as possible before backtracking its step to explore the next branch. Here is an algorithm with one crucial *missing* piece, namely what data structures to use for the collections C and R:

```
1. Create an empty collection R
2. If tree is empty, return R
3. Create a collection C and add the root to it
4. While C is not empty:
    a. Remove the next element (a tree-node) of C
    b. Add its value to R
    c. Add all its children to C
5. Return R
```
This is the same pseudo-code as BFS! The only thing that changes is the data structures you're going to use for C and R. 

Looking at the same example as before, here is the expected result of DFS.
```
  Example tree:

                1
              / | \
             2  3  4
            /|     |\
           5 6     7 8

    DFS should yield: 1, 2, 5, 6, 3, 4, 7, 8
    Since the order of siblings doesn't matter, the following are also valid DFS traversals:
    1, 2, 6, 5, 3, 4, 7, 8
    1, 4, 7, 8, 3, 2, 5, 6
    1, 4, 8, 7, 3, 2, 6, 5
    1, 4, 8, 7, 2, 6, 5, 3
    etc.
```

__Question 2__: 
What data structures should you use for R and C? For each of them, describe what "remove" and "add" means.

Add a method to your tree class that returns the DFS traversal:

```java
public List<T> depthFirstSearch() {
    // TODO: Implement DFS
    // Don't forget to transform your collection R into a list at the end (if it is not already)
}
```

## Part 5: Testing your implementation
A testing class `TestTree` is provided. It contains several test cases that will help you verify the correctness of your implementation. You should run the main method of this class after completing your implementation to test it. You should not be satisified until all test cases pass successfully. (Don't hesitate to add more test cases of your own!)

## Part 6: Getting acquainted with Git and GitHub
You must turn in your homework by *forking* this project repository on GitHub, *committing* your code changes, and *pushing them* to your forked repository. Finally, create a *pull request* to the original repository.

If any of these terms are unfamiliar to you, contact your instructor for help. An introduction to Git and GitHub will be provided in class. You can also refer to the following tutorial: https://docs.github.com/en/get-started/quickstart/hello-world