# Homework Assignment: Tree Traversal with Stacks and Queues

## Overview
In this assignment, you will implement a generic *tree* data structure and use stacks and queues to perform depth-first search (DFS) and breadth-first search (BFS) traversals.

Note that the repository already contains the implementation of generic lists, stacks, and queues seen in class. You can and should reuse them in your implementation. The given implementation of queues contains one more method than what we have seen in class, namely
a `toList` method that may be useful for this assignment.

## Part 1: Tree Node Class
In this section, we implement a generic `TreeNode<T>` class that represents a tree-node. Recall that such a tree-node contains a piece of data (of type `T`) and a collection of children. If the collection of children is empty, the tree-node is called a leaf.

For our implementation, we choose to represent the collection of children of a tree-node as a linked list of linked node.

Our class will have a single constructor that creates a leaf containing the value passed in argument. It must also have methods `addChild`, `getChildren`, and `getValue`.

```java
public class TreeNode<T> {
    T value;
    List<TreeNode<T>> children;

    public TreeNode(T value) {
        this.value = value;
        this.children = new List<TreeNode<T>>();
    }

    public void addChild(TreeNode<T> child) {
        this.children.addOnHead(child);
    }

    public List<TreeNode<T>> getChildren() {
        return this.children;
    }

    public T getValue() {
        return this.value;
    }
}
```

## Part 2: Tree Class
Implement a generic `Tree<T>` class that manages the entire tree structure. A tree is simply, given by a tree-node, named *root*.

The constructor method without argument will make an empty tree. The constructor method with a tree-node argument will construct a tree in which the argument is the root.

We will also need setter and getter methods.

```java
public class Tree<T> {
    TreeNode<T> root;

    public Tree() {
        this.root = null;
    }

    public Tree(TreeNode<T> root) {
        setRoot(root);
    }

    public void setRoot(TreeNode<T> root) {
        this.root = root;
    }

    public TreeNode<T> getRoot() {
        return this.root;
    }
}
```

## Part 3: Breadth-First Search
In this section, we focus on BFS traversals of trees. The idea of BFS is to explore all children of a given node before moving deeper. Here is an algorithm with one crucial *missing* piece, namely what data structures to use for the collections C and R:

```
1. Create an empty collection R
2. If tree is empty, return R
3. Create a collection C and add the root to it
4. While C is not empty:
    a. Remove the next element (a tree-node) of C
    b. Add its value to R
    c. Add all its children to C
5. Return R
```

The following example shows the expected result of BFS.
```
  Example tree:

                1
              / | \
             2  3  4
            /|     |\
           5 6     7 8

    BFS should yield: 1, 2, 3, 4, 5, 6, 7, 8
```

__Question 1__: 
What data structures should you use for R and C? For each of them, describe what "remove" and "add" means.

Add a method to your tree class that returns the BFS traversal:

```java

//R = A generic list that takes each removed value in order.
//C = A TreeNode queue, where each node dequeued has its children enqueued.

public List<T> breadthFirstSearch() {
    List<T> R = new List<T>();
    if (this.root == null)
        return R;
    Queue<TreeNode<T>> C = new Queue<TreeNode<T>>();
    C.enqueue(this.root);
    while (!C.isEmpty()) {
        TreeNode<T> rem = C.dequeue();
        R.addAtEnd(rem.getValue());
        for (TreeNode<T> t : rem.children) {
            C.enqueue(t);
        }
    }
    return R;
}
```

## Part 4: Depth-First Search
In this section, we focus on DFS traversals of trees. The idea of DFS is to explore every branch as deep as possible before backtracking its step to explore the next branch. Here is an algorithm with one crucial *missing* piece, namely what data structures to use for the collections C and R:

```
1. Create an empty collection R
2. If tree is empty, return R
3. Create a collection C and add the root to it
4. While C is not empty:
    a. Remove the next element (a tree-node) of C
    b. Add its value to R
    c. Add all its children to C
5. Return R
```
This is the same pseudo-code as BFS! The only thing that changes is the data structures you're going to use for C and R. 

Looking at the same example as before, here is the expected result of DFS.
```
  Example tree:

                1
              / | \
             2  3  4
            /|     |\
           5 6     7 8

    DFS should yield: 1, 2, 5, 6, 3, 4, 7, 8
    Since the order of siblings doesn't matter, the following are also valid DFS traversals:
    1, 2, 6, 5, 3, 4, 7, 8
    1, 4, 7, 8, 3, 2, 5, 6
    1, 4, 8, 7, 3, 2, 6, 5
    1, 4, 8, 7, 2, 6, 5, 3
    etc.
```

__Question 2__: 
What data structures should you use for R and C? For each of them, describe what "remove" and "add" means.

Add a method to your tree class that returns the DFS traversal:

```java

//R = A generic list that takes each removed value in order.
//C = A TreeNode stack, where each popped root has its children pushed.

public List<T> depthFirstSearch() {
    public List<T> depthFirstSearch() {
        List<T> R = new List<T>();
        if (this.root == null)
            return R;
        Stack<TreeNode<T>> C = new Stack<TreeNode<T>>();
        C.push(this.root);
        while (!C.isEmpty()) {
            TreeNode<T> rem = C.pop();
            R.addAtEnd(rem.getValue());
            for (TreeNode<T> t : rem.children) {
                C.push(t);
            }
        }
        return R;
    }
}
```

## Part 5: Testing your implementation
A testing class `TestTree` is provided. It contains several test cases that will help you verify the correctness of your implementation. You should run the main method of this class after completing your implementation to test it. You should not be satisified until all test cases pass successfully. (Don't hesitate to add more test cases of your own!)

## Part 6: Getting acquainted with Git and GitHub
You must turn in your homework by *forking* this project repository on GitHub, *committing* your code changes, and *pushing them* to your forked repository. Finally, create a *pull request* to the original repository.

If any of these terms are unfamiliar to you, contact your instructor for help. An introduction to Git and GitHub will be provided in class. You can also refer to the following tutorial: https://docs.github.com/en/get-started/quickstart/hello-world